# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Functions to do the decomposition by leveraging Intel MKL
#'
#' @param upper A Boolean value to indicate the output matrix is a upper matrix. False will return a lower matrix.
#' @name fast_matrix_decomposition
#' @export
fMatChol <- function(x, upper = TRUE) {
    .Call('_rmkl_fMatChol', PACKAGE = 'rmkl', x, upper)
}

#' @param economical Whether to use economical SVD.
#' @name fast_matrix_decomposition
#' @export
fMatSvd <- function(x, economical = FALSE) {
    .Call('_rmkl_fMatSvd', PACKAGE = 'rmkl', x, economical)
}

#' @param is_symmetric Whether the matrix is symmetric.
#' @name fast_matrix_decomposition
#' @export
fMatEigen <- function(x, is_symmetric = FALSE) {
    .Call('_rmkl_fMatEigen', PACKAGE = 'rmkl', x, is_symmetric)
}

#' @param permutation_matrix Whether the permutation matrix is outputted.
#' @name fast_matrix_decomposition
#' @export
fMatLu <- function(x, permutation_matrix = FALSE) {
    .Call('_rmkl_fMatLu', PACKAGE = 'rmkl', x, permutation_matrix)
}

#' @name fast_matrix_decomposition
#' @export
fMatSchur <- function(x) {
    .Call('_rmkl_fMatSchur', PACKAGE = 'rmkl', x)
}

#' @name fast_matrix_decomposition
#' @export
fMatQr <- function(x, permutation_matrix = FALSE, economical = FALSE) {
    .Call('_rmkl_fMatQr', PACKAGE = 'rmkl', x, permutation_matrix, economical)
}

#' Functions to use MKL to do the matrix calculations
#'
#' @param x,y matrices
#' @return The result matrices
#'
#' @examples
#' x <- matrix(rnorm(1e4), 100)
#' y <- matrix(rnorm(1e2), 100)
#' z <- matrix(rnorm(1e4), 100)
#' XtX <- fMatProd(t(x), x)
#' XtX2 <- fMatTransProd(x, x)
#' all.equal(XtX, XtX2) # TRUE
#' invXtX <- fMatInv(XtX)
#' invXtXy <- fMatSolve(XtX, y)
#' fMatAdd(x, z) # x + z
#' fMatSubtract(x, z) # x - z
#' fMatSumDiffSquared(x, z) # sum((x-z)^2)
#' @name fast_matrix_ops
#' @export
fMatProd <- function(x, y) {
    .Call('_rmkl_fMatProd', PACKAGE = 'rmkl', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatTransProd <- function(x, y) {
    .Call('_rmkl_fMatTransProd', PACKAGE = 'rmkl', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatSolve <- function(x, y) {
    .Call('_rmkl_fMatSolve', PACKAGE = 'rmkl', x, y)
}

#' @param is_sym_pd Whether the input matrix is symmetric/hermitian positive definite.
#' @name fast_matrix_ops
#' @export
fMatInv <- function(x, is_sym_pd = FALSE) {
    .Call('_rmkl_fMatInv', PACKAGE = 'rmkl', x, is_sym_pd)
}

#' @name fast_matrix_ops
#' @export
fMatPseudoInv <- function(x) {
    .Call('_rmkl_fMatPseudoInv', PACKAGE = 'rmkl', x)
}

#' @name fast_matrix_ops
#' @export
fMatAdd <- function(x, y) {
    .Call('_rmkl_fMatAdd', PACKAGE = 'rmkl', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatSubtract <- function(x, y) {
    .Call('_rmkl_fMatSubtract', PACKAGE = 'rmkl', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatSumDiffSquared <- function(x, y) {
    .Call('_rmkl_fMatSumDiffSquared', PACKAGE = 'rmkl', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatDet <- function(x) {
    .Call('_rmkl_fMatDet', PACKAGE = 'rmkl', x)
}

#' @param dim The sorting dimention. 1 means row. 2 means column.
#' @param ascending Whether to sort by ascending order.
#' @name fast_matrix_ops
#' @export
fMatSort <- function(x, dim = 1L, ascending = TRUE) {
    .Call('_rmkl_fMatSort', PACKAGE = 'rmkl', x, dim, ascending)
}

#' @name fast_matrix_ops
#' @export
fMatUnique <- function(x) {
    .Call('_rmkl_fMatUnique', PACKAGE = 'rmkl', x)
}

#' Function to get the version of Intel MKL
#'
#' @return The version of Intel MKL
#' @examples
#' getMKLVersion()
#' @export
getMKLVersion <- function() {
    .Call('_rmkl_getMKLVersion', PACKAGE = 'rmkl')
}

#' Function to get/set the number of threads used in Intel MKL
#'
#' @param nThreads The number of threads you want to use in Intel MKL.
#' @return The number of threads.
#'
#' @examples
#' \dontrun{
#' getMKLThreads() # Default is the number of cores your CPU has
#' setMKLThreads(1)
#' getMKLThreads() # 1
#' }
#' @name mkl_threads
#' @export
setMKLThreads <- function(nThreads) {
    .Call('_rmkl_setMKLThreads', PACKAGE = 'rmkl', nThreads)
}

#' @name mkl_threads
#' @export
getMKLThreads <- function() {
    .Call('_rmkl_getMKLThreads', PACKAGE = 'rmkl')
}

